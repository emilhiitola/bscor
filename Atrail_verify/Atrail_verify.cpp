/*
 * Atrail_verify.cpp
 *
 *  Created on: Jul 17, 2013
 *  Author: Abdulmelik Mohammed
 *  Verifies that an edge trail generated by an Atrail_search is in fact an A-trail with respect to the embedding given as an edge code.
 *  Argument 1: the edge code file.
 *  Argument 2: the edge trail file.
 */

#include <iostream>
#include <vector>
#include <list>
#include <iterator>
#include <string>
#include <sstream>
#include <fstream>
#include <stdio.h>
#include "boost_graph_helper.hpp"

// Reads the edge trail in the file input_filename and outputs the resulting trail in the list structure.
bool read_trail(std::string input_filename, std::list<std::size_t> & trail);

// Checks whether the trail trail_edgelist is an A-trail with respect to the embedding given by the edge code.
// Precondition: The edge code is a valid embedding of a graph. The trail edgelist is a sequence of edge indices (unsigned integers from 0 to m-1)
bool Atrail_verify(const std::vector<std::vector<std::size_t> > & edge_code,  const std::list<std::size_t> & trail_edgelist);

int main(int argc, char* argv[])
{
	std::cout<<"INFO: Atrail_verify, verifies whether the given trail is a valid Atrail with respect to the given planar embedding."<<std::endl;
	if(argc != 3)
	{
		std::cerr << "ERROR! Usage: Atrail_verify edgecodefile edgetrailfile" << std::endl;
		return 1;
	}else
	{
		std::vector<std::vector<size_t> > edge_code;
		std::list<std::size_t> edge_trail;
		if(!read_edge_code(std::string(argv[1]), edge_code)) return 1;
		std::cout<<"INFO: Reading trail from file "<<std::string(argv[2])<<std::endl;
		if(!read_trail(std::string(argv[2]), edge_trail)) return 1;
		print_walk(edge_trail, "INFO: Trail from file: ");
		std::cout<<"INFO: "<<((Atrail_verify(edge_code, edge_trail) == true) 
				? "Yes, the given trail is a valid A-trail with respect to the embedding" : 
				"No, the given trail is not a valid A-trail with respect to the embedding")<<std::endl;
		return 0;
	}
}

bool read_trail(std::string input_filename, std::list<std::size_t> & trail)
{
	std::ifstream ifs(input_filename.c_str(), std::ifstream::in);
	if( !ifs.is_open())
	{
		std::cerr<<"ERROR! Unable to read file "<<input_filename;
		return false;
	}else
	{
		trail.clear();
		//trail = std::list<std::size_t>(0);
		std::string line;
		std::getline(ifs, line);
		std::istringstream iss(line);
		std::size_t next_edge;
		while(iss >> next_edge) {
			trail.push_back(next_edge);
		}
		ifs.close();
		return true;
	}
}

bool Atrail_verify(const std::vector<std::vector<std::size_t> > & edge_code,  const std::list<std::size_t> & trail_edgelist)
{
	std::size_t m = 0; // number of edges
	for( unsigned int i = 0; i < edge_code.size(); ++i ) m += edge_code[i].size();
	m = m / 2;
	std::vector<unsigned short> num_visits(m, 0);
	std::vector<std::vector<unsigned int> > ind2pair(m, std::vector<unsigned int>(0));
	for( unsigned int i = 0; i < edge_code.size(); ++i)
	{
		for( unsigned int j = 0; j < edge_code[i].size(); ++j)
		{
			ind2pair[edge_code[i][j]].push_back(i);
		}
	}

	if( m != trail_edgelist.size()) return false;
	else if (trail_edgelist.size() == 0)
	{
		std::cerr<<"ERROR! The trail is empty!"<<std::endl;
		return false;
	}
	else{
		//If the trail list begins with parallel edges e1 and e2 (i.e e1 and e2 have the same end nodes u,v), 
		//is the trail to be interpreted as u,e1,v,e2,u or v,e1,u,e2,v? The trail may be valid with one interpretation
		//but invalid with the other. We use the optimistic interpretation and check both in two rounds.		
		Vertex next = ind2pair[trail_edgelist.front()][1];		
		unsigned char round = 0; 
		bool is_valid_trail = true; // Is it a valid Eulerian trail?
		bool is_valid_Atrail = true; // Is it a valid Atrail?
		while(round < 2)
		{
			std::size_t loc, pre, suc;
			std::list<std::size_t>::const_iterator nextedge;
			is_valid_trail = true;
			is_valid_Atrail = true;
			for( std::list<std::size_t>::const_iterator it = trail_edgelist.begin(); it!= trail_edgelist.end(); ++it)
			{
				if((++num_visits[*it]) > 1)
				{
					is_valid_trail = false; // An edge is visited more than once
				}
				if( it != (--trail_edgelist.end()))
				{
					nextedge = ++it;
					--it;
				}else nextedge = trail_edgelist.begin();

				loc = std::distance(edge_code[next].begin(), std::find(edge_code[next].begin(),edge_code[next].end(), *(it)));
				pre = ((loc == edge_code[next].size() - 1)? 0 : (loc + 1));
				suc = ((loc == 0) ? (edge_code[next].size() - 1):(loc - 1));
				if( edge_code[next][pre] != *nextedge
						&& edge_code[next][suc] != *nextedge )
				{
					// The two consecutive edges are not neighbors in the cyclic order of edges around the joining node
					is_valid_Atrail = false;
					break;
				}
				next = (ind2pair[*nextedge][0] == next ? ind2pair[*nextedge][1] : ind2pair[*nextedge][0]);
			}
			if(!is_valid_trail) break;
			if( is_valid_trail && is_valid_Atrail) break;
			round++;
			next = ind2pair[trail_edgelist.front()][0]; // if it fails try the other interpretation.
			num_visits = std::vector<unsigned short>(m,0);
		}

		return is_valid_trail && is_valid_Atrail;
	}
}
